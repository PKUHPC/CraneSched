name: Build, Upload and Test

on:
  schedule:
    - cron: "0 22 * * *"  # UTC 22:00 = CST 06:00 (next day)
  push:
    branches:
      - master
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
    branches:
      - master
      - release/*
  workflow_dispatch:
    inputs:
      backend_ref:
        description: 'Backend ref to use (branch name, tag, or commit SHA)'
        required: false
        default: ''
      frontend_ref:
        description: 'FrontEnd ref to use (branch name, tag, or commit SHA)'
        required: false
        default: ''
      cache_buster:
        description: 'Optional cache buster to force rebuild (any non-empty string)'
        required: false
        default: ''

concurrency:
  group: >-
    ${{ github.event_name == 'pull_request'
        && format('pr-{0}', github.event.pull_request.number)
        || format('ref-{0}', github.ref) }}
  cancel-in-progress: true

env:
  # Self-hosted runner paths
  SCRIPT_PATH: /opt/actions-runner-external/script
  CACHE_PATH: /opt/actions-runner-external/cache

  # Local cache directory
  LOCAL_CACHE_DIR: /opt/actions-runner-external/runner_cache

  # Cache buster for forcing rebuilds on workflow_dispatch
  CACHE_BUSTER: ${{ inputs.cache_buster || '' }}

  # CI image tag (digest resolved at runtime)
  CI_IMAGE_TAG: ghcr.io/nativu5/cranedev:ci

jobs:

  prepare:
    if: github.event_name != 'pull_request' || !github.event.pull_request.draft
    runs-on: ubuntu-latest
    outputs:
      backend_ref: ${{ steps.set_ref.outputs.backend_ref }}
      frontend_ref: ${{ steps.set_ref.outputs.frontend_ref }}
    defaults:
      run:
        shell: bash -leo pipefail {0}
    steps:
      - name: Decide backend and frontend refs
        id: set_ref
        run: |
          set -euo pipefail
          DEFAULT_BRANCH="master"
          
          # Determine backend ref
          BACKEND_REF=""
          if [ -n "${{ github.event.inputs.backend_ref || '' }}" ]; then
            BACKEND_REF="${{ github.event.inputs.backend_ref }}"
            echo "Using backend ref: $BACKEND_REF"
          fi
          # If empty, actions/checkout will use the default ref
          
          # Determine frontend ref
          FRONTEND_REF="$DEFAULT_BRANCH"
          if [ -n "${{ github.event.inputs.frontend_ref || '' }}" ]; then
            FRONTEND_REF="${{ github.event.inputs.frontend_ref }}"
            echo "Using frontend ref: $FRONTEND_REF"
          elif [ "${GITHUB_EVENT_NAME}" = "pull_request" ]; then
            CANDIDATE="${GITHUB_HEAD_REF}"
            echo "Checking if FrontEnd has branch: $CANDIDATE"
            if git ls-remote --exit-code --heads https://github.com/PKUHPC/CraneSched-FrontEnd.git "$CANDIDATE"; then
              FRONTEND_REF="$CANDIDATE"
              echo "Found matching FrontEnd branch: $FRONTEND_REF"
            fi
          fi
          
          echo "backend_ref=$BACKEND_REF" >> $GITHUB_OUTPUT
          echo "frontend_ref=$FRONTEND_REF" >> $GITHUB_OUTPUT
          echo "Backend ref: $BACKEND_REF (empty means default)"
          echo "Frontend ref: $FRONTEND_REF"

  build:
    needs: prepare
    runs-on: [ "self-hosted", "CraneSched" ]

    env:
      BACKEND_REF: ${{ needs.prepare.outputs.backend_ref }}
      FRONTEND_REF: ${{ needs.prepare.outputs.frontend_ref }}

    defaults:
      run:
        shell: bash -leo pipefail {0}

    outputs:
      output_bundle_artifact: build-output
      output_meta_artifact: build-meta
      key_sha256: ${{ env.KEY_SHA256 }}

    steps:
      # Checkout backend repository
      - name: Checkout backend
        uses: actions/checkout@v4
        with:
          path: CraneSched
          ref: ${{ env.BACKEND_REF || github.ref }}

      # Checkout frontend repository at unified ref
      - name: Checkout frontend
        uses: actions/checkout@v4
        with:
          repository: PKUHPC/CraneSched-FrontEnd
          path: CraneSched-FrontEnd
          ref: ${{ env.FRONTEND_REF }}

      # Resolve CI image digest (kept for metadata/fingerprint; not pinning run)
      - name: Resolve CI image digest
        id: imagedigest
        run: |
          set -euo pipefail
          IMG="${CI_IMAGE_TAG}"

          resolve_with_skopeo() {
            command -v skopeo >/dev/null 2>&1 || return 1
            DIGEST=$(skopeo inspect "docker://${IMG}" | jq -r '.Digest' 2>/dev/null) || return 1
            [ -n "${DIGEST}" ] || return 1
            echo "${DIGEST}"
          }

          resolve_with_manifest() {
            command -v podman >/dev/null 2>&1 || return 1
            RAW=$(podman manifest inspect "${IMG}" 2>/dev/null) || return 1
            if echo "${RAW}" | jq -e '.manifests' >/dev/null 2>&1; then
              ARCH=$(uname -m)
              OS=$(uname -s | awk '{print tolower($0)}')
              [ "$ARCH" = "x86_64" ] && ARCH="amd64"
              DIGEST=$(echo "${RAW}" | jq -r --arg arch "$ARCH" --arg os "$OS" \
                '.manifests[] | select(.platform.architecture==$arch and .platform.os==$os) | .digest' | head -n1)
              [ -z "${DIGEST}" -o "${DIGEST}" = "null" ] && DIGEST=$(echo "${RAW}" | jq -r '.manifests[0].digest')
            fi
            [ -z "${DIGEST:-}" -o "${DIGEST}" = "null" ] && DIGEST=$(echo "${RAW}" | jq -r '.config.digest' 2>/dev/null || true)
            [ -n "${DIGEST:-}" ] && [ "${DIGEST}" != "null" ] || return 1
            echo "${DIGEST}"
          }

          resolve_with_pull() {
            command -v podman >/dev/null 2>&1 || return 1
            podman pull "${IMG}" >/dev/null
            podman image inspect "${IMG}" --format '{{.Digest}}'
          }

          DIGEST="$(resolve_with_skopeo || true)"
          [ -z "$DIGEST" ] && DIGEST="$(resolve_with_manifest || true)"
          [ -z "$DIGEST" ] && DIGEST="$(resolve_with_pull || true)"
          [ -z "$DIGEST" ] && { echo "ERROR: failed to resolve digest for ${IMG}" >&2; exit 1; }

          echo "CI_IMAGE_DIGEST=${DIGEST}" | tee -a "$GITHUB_ENV"
          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"

      # Compute fingerprint and its sha256 key
      - name: Compute fingerprint
        id: fp
        run: |
          set -euo pipefail
          CRANE_SHA=$(git -C CraneSched rev-parse HEAD)
          FE_SHA=$(git -C CraneSched-FrontEnd rev-parse HEAD)
          FE_REF="${FRONTEND_REF}"
          CI_DIGEST="${CI_IMAGE_DIGEST}"
          FINGERPRINT="${CRANE_SHA}-${FE_REF}-${FE_SHA}-${CI_DIGEST}-${CACHE_BUSTER}"

          KEY_SHA256=$(printf '%s' "$FINGERPRINT" | sha256sum | awk '{print $1}')
          CACHE_TGZ="${LOCAL_CACHE_DIR}/${KEY_SHA256}.tar.gz"
          CACHE_META="${LOCAL_CACHE_DIR}/${KEY_SHA256}.meta.json"

          echo "CRANE_SHA=${CRANE_SHA}" >> "$GITHUB_ENV"
          echo "FE_SHA=${FE_SHA}"       >> "$GITHUB_ENV"
          echo "FE_REF=${FE_REF}"       >> "$GITHUB_ENV"
          echo "FINGERPRINT=${FINGERPRINT}" >> "$GITHUB_ENV"
          echo "KEY_SHA256=${KEY_SHA256}"   >> "$GITHUB_ENV"
          echo "CACHE_TGZ=${CACHE_TGZ}"     >> "$GITHUB_ENV"
          echo "CACHE_META=${CACHE_META}"   >> "$GITHUB_ENV"

      # Prepare workspace & local cache dir
      - name: Prepare workspace & local cache
        run: |
          set -euo pipefail
          ln -sfT "$SCRIPT_PATH" "$(pwd)/script"
          ln -sfT "$CACHE_PATH"  "$(pwd)/cache"
          mkdir -p output log
          mkdir -p "${LOCAL_CACHE_DIR}" || true
          chown "$(id -u)":"$(id -g)" "${LOCAL_CACHE_DIR}" || true
          ls -ld "${LOCAL_CACHE_DIR}"

      # Local cache lookup with checksum verification
      - name: Local cache lookup
        id: local_cache
        run: |
          set -euo pipefail
          HIT=false
          if [ -f "${CACHE_TGZ}" ] && [ -f "${CACHE_META}" ]; then
            echo "Found local cache files:"
            ls -lh "${CACHE_TGZ}" "${CACHE_META}"
            EXPECT_SHA=$(jq -r '.sha256 // empty' "${CACHE_META}" || true)
            if [ -n "${EXPECT_SHA}" ]; then
              ACTUAL_SHA=$(sha256sum "${CACHE_TGZ}" | awk '{print $1}')
              if [ "${EXPECT_SHA}" = "${ACTUAL_SHA}" ]; then
                echo "Local cache checksum OK."
                rm -rf output/*; mkdir -p output
                tar -xzf "${CACHE_TGZ}" -C output
                HIT=true
              else
                echo "WARN: checksum mismatch, ignoring local cache."
              fi
            else
              echo "WARN: missing sha256 in meta.json, ignoring local cache."
            fi
          else
            echo "Local cache NOT found."
          fi
          echo "hit=${HIT}" >> "$GITHUB_OUTPUT"
          echo "LOCAL_CACHE_HIT=${HIT}" >> "$GITHUB_ENV"

      # Pull CI Image only if local cache missed
      - name: Pull CI Image (only on miss)
        if: steps.local_cache.outputs.hit != 'true'
        run: |
          podman pull "${CI_IMAGE_TAG}"

      # Build in container only if local cache missed
      - name: Build in Container (only on miss)
        if: steps.local_cache.outputs.hit != 'true'
        run: |
          podman run --rm \
              -v ./CraneSched:/Workspace/CraneSched \
              -v ./CraneSched-FrontEnd:/Workspace/CraneSched-FrontEnd \
              -v ./output:/Workspace/output \
              -v ./script:/Workspace/script \
              -v ./cache/ccache:/root/.ccache \
              "${CI_IMAGE_TAG}" /bin/bash --login script/build.sh

      # Validate non-empty output
      - name: Validate non-empty output
        run: |
          if ! find output -type f -print -quit | grep -q .; then
            echo "ERROR: output/ is empty; failing early." >&2
            ls -la output || true
            exit 1
          fi

      # Create bundle tar.gz
      - name: Create bundle (tar.gz)
        run: |
          rm -f build-output.tar.gz
          tar -czf build-output.tar.gz --exclude='*debug*' -C output .

      # Generate meta.json
      - name: Generate meta.json
        run: |
          set -euo pipefail
          TS="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          RUN_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          SIZE_BYTES=$(stat -c %s build-output.tar.gz)
          SHA256=$(sha256sum build-output.tar.gz | awk '{print $1}')
          RUNNER_HOST="$(hostname)"
          RUNNER_UNAME="$(uname -srmo)"

          jq -n \
            --arg fingerprint "${FINGERPRINT}" \
            --arg key_sha256 "${KEY_SHA256}" \
            --arg created_utc "${TS}" \
            --arg github_run "${RUN_URL}" \
            --arg backend_sha "${CRANE_SHA}" \
            --arg frontend_ref "${FE_REF}" \
            --arg frontend_sha "${FE_SHA}" \
            --arg ci_image_tag "${CI_IMAGE_TAG}" \
            --arg ci_image_digest "${CI_IMAGE_DIGEST}" \
            --arg cache_buster "${CACHE_BUSTER}" \
            --arg sha256 "${SHA256}" \
            --arg runner_host "${RUNNER_HOST}" \
            --arg runner_uname "${RUNNER_UNAME}" \
            --argjson size_bytes "${SIZE_BYTES}" \
            '{
              fingerprint: $fingerprint,
              key_sha256: $key_sha256,
              created_utc: $created_utc,
              github_run: $github_run,
              backend_sha: $backend_sha,
              frontend_ref: $frontend_ref,
              frontend_sha: $frontend_sha,
              ci_image_tag: $ci_image_tag,
              ci_image_digest: $ci_image_digest,
              cache_buster: $cache_buster,
              size_bytes: $size_bytes,
              sha256: $sha256,
              runner_host: $runner_host,
              runner_uname: $runner_uname
            }' > meta.json

          cp -f meta.json output/meta.json

      # Save to local cache only when built (miss case)
      - name: Save to local cache (only on miss)
        if: steps.local_cache.outputs.hit != 'true'
        run: |
          set -euo pipefail
          TMP_DIR="${LOCAL_CACHE_DIR}/${KEY_SHA256}.tmp"
          mkdir -p "${TMP_DIR}"
          cp -f build-output.tar.gz "${TMP_DIR}/"
          cp -f meta.json "${TMP_DIR}/${KEY_SHA256}.meta.json"
          # Atomic publish
          rm -f "${CACHE_TGZ}" "${CACHE_META}" || true
          mv -f "${TMP_DIR}/build-output.tar.gz" "${CACHE_TGZ}"
          mv -f "${TMP_DIR}/${KEY_SHA256}.meta.json" "${CACHE_META}"
          rmdir "${TMP_DIR}" || true
          echo "Local cache stored: ${CACHE_TGZ}"

      # Upload large bundle artifact (note: artifact name != file name)
      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: build-output.tar.gz
          retention-days: 3
          if-no-files-found: error

      # Upload lightweight meta artifact
      - name: Upload meta artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-meta
          path: meta.json
          retention-days: 3
          if-no-files-found: error
      
      # Upload RPM/DEB to private repository (only on miss)
      - name: Upload to private repository (only on miss)
        if: steps.local_cache.outputs.hit != 'true'
        continue-on-error: true
        env: 
          NEXUS_URL: ${{ secrets.CCREPO_URL }}
          NEXUS_USERNAME: ${{ secrets.CCREPO_USERNAME }}
          NEXUS_PASSWORD: ${{ secrets.CCREPO_PASSWORD }}

          VERSION: >- 
            ${{ (github.event_name == 'pull_request')
            && format('pr-{0}', github.event.number)
            || github.ref_name }}

          RPM_REPO_NAME: "crane"
          RPM_ARCH: "x86_64"
          RPM_DISTRO: "8"

          DEB_REPO_NAME: "cranedeb"
          DEB_ARCH: "amd64"
          DEB_DISTRO: "bullseye"

          PACKAGE_DIR: ./output
          CONTINUE_ON_ERROR: true

          UPLOAD_MODE: "RPM"  # Currently only upload RPMs in this workflow

        run: |
          set -euo pipefail
          
          # Check if secrets are available (they won't be in forked repositories)
          if [ -z "${NEXUS_URL:-}" ] || [ -z "${NEXUS_USERNAME:-}" ] || [ -z "${NEXUS_PASSWORD:-}" ]; then
            echo "Skipping upload: Repository secrets not available"
            echo "This is expected for forked repositories and does not affect build/test results."
            exit 0
          fi
          
          unset http_proxy https_proxy HTTP_PROXY HTTPS_PROXY
          ./script/upload.sh

  test:
    needs: [ prepare, build ]
    runs-on: [ "self-hosted", "CraneSched" ]
    defaults:
      run:
        shell: bash -leo pipefail {0}
    env:
      TEST_FAILED: false
      BACKEND_REF: ${{ needs.prepare.outputs.backend_ref }}
      FRONTEND_REF: ${{ needs.prepare.outputs.frontend_ref }}

    steps:
      # Prepare workspace for AutoTest
      - name: Prepare workspace
        run: |
          ln -sfT "$SCRIPT_PATH" "$(pwd)/script"
          ln -sfT "$CACHE_PATH"  "$(pwd)/cache"
          mkdir -p output log

      # Download lightweight meta first (small; fast)
      - name: Download meta
        uses: actions/download-artifact@v5
        with:
          name: ${{ needs.build.outputs.output_meta_artifact }}   # build-meta
          path: .

      # Try local cache using key & sha from meta.json
      - name: Try local cache first
        id: local_first
        run: |
          set -euo pipefail
          META_FILE="./meta.json"
          [ -f "$META_FILE" ] || { echo "meta.json missing"; exit 1; }

          KEY_SHA256=$(jq -r '.key_sha256' "$META_FILE")
          BUNDLE_SHA=$(jq -r '.sha256' "$META_FILE")
          echo "KEY_SHA256=$KEY_SHA256" | tee -a "$GITHUB_ENV"

          CACHE_TGZ="${LOCAL_CACHE_DIR}/${KEY_SHA256}.tar.gz"
          CACHE_META="${LOCAL_CACHE_DIR}/${KEY_SHA256}.meta.json"

          HIT=false
          if [ -f "$CACHE_TGZ" ] && [ -f "$CACHE_META" ]; then
            EXPECT_SHA=$(jq -r '.sha256 // empty' "$CACHE_META")
            if [ -n "$EXPECT_SHA" ]; then
              ACTUAL_SHA=$(sha256sum "$CACHE_TGZ" | awk '{print $1}')
              if [ "$EXPECT_SHA" = "$ACTUAL_SHA" ] && [ "$EXPECT_SHA" = "$BUNDLE_SHA" ]; then
                echo "Local cache valid. Using ${CACHE_TGZ}"
                rm -rf output/*; mkdir -p output
                tar -xzf "$CACHE_TGZ" -C output
                HIT=true
              else
                echo "WARN: local cache sha mismatch. meta=$EXPECT_SHA actual=$ACTUAL_SHA build=$BUNDLE_SHA"
              fi
            fi
          else
            echo "Local cache NOT found for KEY=$KEY_SHA256"
          fi

          echo "hit=${HIT}" >> "$GITHUB_OUTPUT"

      # Fallback: download large bundle artifact only if local cache missed
      - name: Download bundle (fallback)
        if: steps.local_first.outputs.hit != 'true'
        uses: actions/download-artifact@v5
        with:
          name: ${{ needs.build.outputs.output_bundle_artifact }}  # build-output
          path: .

      # Fallback: extract bundle from artifact directory
      - name: Extract bundle (fallback)
        if: steps.local_first.outputs.hit != 'true'
        run: |
          set -euo pipefail
          rm -rf output/*; mkdir -p output
          tar -xzf build-output.tar.gz -C output

      # Run AutoTest
      - name: Run AutoTest
        continue-on-error: true
        run: |
          NETWORK_ID=$(podman container inspect mongodb | jq -r '.[0].NetworkSettings.Networks | keys[]' || echo "testnetwork")
          if [ -z "$NETWORK_ID" ]; then
            echo "WARN: mongodb container network not found; falling back to default podman network"
          fi
          podman run -d --rm --name autotest \
            --privileged \
            --systemd true \
            -v /lib/modules:/lib/modules:ro \
            -v ./script:/CraneSched-AutoTest/script \
            -v ./output:/CraneSched-AutoTest/output \
            -v ./log:/CraneSched-AutoTest/log \
            -v /tmp/crane/tls:/etc/crane/tls:Z \
            $( [ -n "$NETWORK_ID" ] && echo "--network $NETWORK_ID" ) \
            localhost/autotest
          podman exec autotest /bin/bash --login script/run.sh || echo "TEST_FAILED=true" >> $GITHUB_ENV
          podman stop autotest || true

      # Upload AutoTest results
      - name: Upload AutoTest Results
        uses: actions/upload-artifact@v4
        with:
          name: result.json
          path: output/result.json
          retention-days: 3
          if-no-files-found: error

      # Fail the job if tests failed
      - name: Alarm on test failure
        if: env.TEST_FAILED == 'true'
        run: exit 1
